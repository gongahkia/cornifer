x (A) Write scrapers that scrape the climber hold maker websites for generic climbing hold images @dev @scraper
x (A) Write scrapers that scrape the training board makers for training board images @dev @scraper
x (A) Learn how OpenCV works by following along with a worked example +deploy @dev 
x (A) Write helper function that automatically reads log.json and downloads the image at the specified URL to a local folder @dev @scraper
x (A) Add an architecture diagram in the README.md once the workflow is pretty much nailed down @dev @computer

(A) Try openCV for the climbing holds first @dev @opencv
(A) Try openCV for the training boards after that @dev @opencv
(A) Then ask chatgpt how I can use that openCV data to make a stokt-like app @dev @opencv
(A) Then ask chatgpt how to encode that data to a model @dev @opencv
(A) Set up requirements.txt with all dependencies +deploy @dev @computer
(A) Set up basic OpenCV environment and dependencies +setup @opencv @dev

(A) Load images of climbing holds using OpenCV. +detection
(A) Convert images to grayscale to simplify processing. +detection
(A) Apply Gaussian Blur to reduce noise and improve contour detection. +detection
(A) Implement thresholding techniques (e.g., binary thresholding, Otsu's method) to isolate climbing holds from the background. +detection
(A) Use cv2.findContours() to detect contours in the thresholded image. +detection
(A) Filter contours based on size and shape to focus on relevant climbing holds. +detection
(A) Draw contours or bounding boxes around detected holds using cv2.drawContours(). +detection
(A) Create a function to allow users to select highlighted holds (e.g., click events). +detection
(A) Design a simple frontend interface for users to upload images and view detected holds. +detection
(A) Implement functionality to allow users to set custom climbing problems based on selected holds. +detection
(A) Test the application with various images of climbing holds. +detection
(A) Collect feedback from users and iterate on the detection algorithm for improvements. +detection
(A) Document the code and provide usage instructions for the application by cleaning up the README.md +detection

(A) Create hold detection prototype using basic shape recognition +detection @opencv @dev
(A) Implement color-based hold segmentation +detection @opencv @computer
(A) Create initial dataset structure for hold images +data @computer
(A) Set up basic NICEGUI project structure +setup @frontend @dev
(A) Create simple route visualization page +ui @frontend @computer
(A) Implement basic image upload functionality +ui @frontend @dev

(B) Collect a corpus of images of climbing holds categorized by style or problem type. +ml @dev
(B) Organize images into labeled directories for supervised learning. +ml @dev
(B) Split the dataset into training, validation, and test sets. +ml @dev
(B) Research suitable models for image classification (e.g., CNNs, transfer learning with pre-trained models like VGG16 or ResNet). +ml @dev
(B) Decide on the framework (TensorFlow or PyTorch) based on familiarity and project needs. +ml @dev
(B) Build the model architecture using chosen layers (convolutional, pooling, dense). +ml @dev
(B) Compile the model with appropriate loss functions and optimizers. +ml @dev
(B) Implement data augmentation techniques to improve model robustness. +ml @dev
(B) Train the model on the training set while monitoring validation performance. +ml @dev
(B) Save checkpoints of the model during training. +ml @dev
(B) Evaluate model performance on the test set using metrics like accuracy, precision, recall, and F1-score. +ml @dev
(B) Analyze misclassified examples to identify areas for improvement. +ml @dev
(B) Experiment with hyperparameter tuning (learning rate, batch size) to enhance performance. +ml @dev
(B) Consider implementing techniques like dropout or batch normalization to reduce overfitting. +ml @dev
(B) Prepare the trained model for deployment (e.g., convert to TensorFlow Serving format). +ml @dev
(B) Integrate the model into the frontend application so users can classify climbing problems based on uploaded images. +ml @dev
(B) Document the model training process, including data preparation steps and evaluation metrics within the README.md +ml @dev

(B) Create basic neural network architecture for style recognition +ml @neural @research
(B) Implement initial training pipeline +ml @neural @computer
(B) Collect and label training data from different gyms +data @collection @gym
(B) Create data augmentation pipeline +data @computer
(B) Build gym style classification dataset +ml @data @gym
(B) Add style analysis results display +ui @frontend @computer
(B) Create interactive hold selection interface +ui @frontend @dev
(B) Implement route drawing functionality +ui @frontend @dev

(C) Write unit tests for hold detection +testing @dev @computer
(C) Create validation dataset for hold detection +testing @gym @computer
(C) Implement accuracy metrics for style recognition +ml @testing @computer
(C) Create automated testing pipeline +ci @testing @dev

(C) Create Docker container for local deployment +deploy @dev @computer
(C) Create docker-compose for local development +deploy @dev @computer
(C) Write basic installation documentation +docs @computer
(C) Set up CI/CD pipeline +ci @dev @computer
(C) Write basic health checks for services +deploy @testing @dev
(C) Set up environment variable configuration +deploy @dev @computer
(C) Create deployment documentation for local setup +docs @computer

(C) Set up MongoDB container for data persistence +deploy @db @dev
(C) Configure nginx reverse proxy +deploy @dev @computer
(C) Set up Redis for caching if needed +deploy @db @dev
(C) Create backup strategy for trained models +deploy @data @computer
(C) Configure logging and monitoring +deploy @dev @computer

(C) Write make commands for common operations +deploy @dev @computer
(C) Create shell scripts for deployment steps +deploy @dev @computer
(C) Document system requirements and dependencies +docs @computer
(C) Write troubleshooting guide +docs @computer

(C) Set up GitHub Actions workflow +ci @dev @computer
(C) Configure automated testing in CI pipeline +ci @testing @dev
(C) Set up automated Docker image builds +ci @dev @computer
(C) Configure staging environment +deploy @dev @computer
(C) Set up automated deployment to staging +ci @dev @computer

(C) Create basic security configuration +deploy @security @dev
(C) Set up SSL/TLS certificates +deploy @security @dev
(C) Configure rate limiting +deploy @security @dev
(C) Set up automated security scanning +ci @security @dev